open Ast
let varname id =
  match id with 
  | Some id -> "var_" ^ string_of_int id ^ "_QDBP_VAR"
  | None -> "error"
(* FIXME: Name better *)
(* FIXME: Use a paren function for parenthesizing stuff *)
(* FIXME: Use a quote function for qutoing stuff *)
let varname2 origin =
  match origin with 
  | Some id -> varname id 
  | None -> "error"
let rec ocaml_of_ast ast =
  match ast with
  | RecordExtension re -> 
    let name = re.field.field_name in 
    let meth = ocaml_fn_of_method re.field.field_value in
    let rest = ocaml_of_ast re.extension in
    "(Extension {" ^
    "field_name = \"" ^ name ^ "\"; " ^
    "field_method = " ^ meth ^ "; " ^
    "extension = (" ^ rest ^ ")})"
  | EmptyRecord -> "(emptyrecord)"
  | Abort -> "(abort ())"
  | IntLiteral i -> "(int_object " ^ (string_of_int i) ^ ")"
  | StringLiteral s -> "(string_object " ^ "\"" ^ s ^ "\"" ^ ")"
  | Record_Message rm -> 
    "((select (\"" ^ rm.rm_message ^ "\") (" ^ (ocaml_of_ast rm.rm_receiver) ^ ")) [" ^
    List.fold_left (fun acc param -> 
        acc ^ 
        (if ((String.length acc) = 0) then "" else ";")
        ^ " (" ^ ocaml_of_ast param.value ^ ")") 
      "" rm.rm_arguments ^ "])"
  | Sequence s ->
    "(\n" ^ (ocaml_of_ast s.l) ^ " ; \n" ^ (ocaml_of_ast s.r) ^ "\n)"
  | Declaration d ->
    "let " ^ (varname d.decl_id) ^ " = " ^ (ocaml_of_ast d.decl_rhs) ^ " in emptyrecord"
  | Variable v -> varname2 v.origin
  | OcamlCall oc -> 
    let args = List.map ocaml_of_ast oc.fn_args in 
    let paren s = "(" ^ s ^ ")" in 
    let args = List.map paren args in 
    let args = String.concat " " args in 
    "(" ^ oc.fn_name ^ " " ^ (args) ^ ")"
  | Import i ->
    "(" ^ ocaml_of_ast i.import_expr ^ ")"
and ocaml_fn_of_method meth =
  let param_decls = List.fold_left
      (fun acc arg_id -> acc ^ 
                         "let " ^ (varname arg_id) ^ " = " ^ "List.hd params" ^ " in\n" ^
                         "let params = List.tl params in\n") "" meth.arg_ids in
  let body = (ocaml_of_ast meth.method_body) in
  let fn_decl = "\n(fun (params: (record list)): record ->\n" ^ param_decls ^ body ^ ")" in
  fn_decl
let prelude = 
(* FIXME: Move this to another file *)
(* FIXME: Split stuff up into modules *)
(* FIXME: Use multiline string syntax *)
"
[@@@warning \"-10\"]
[@@@warning \"-26\"]
type base_object =
  | Int of int
  | String of string
  | EmptyRecord
type record =
  | Extension of record_extension
  | Empty of base_object
and record_extension =
  {field_name: string;
   field_method: meth;
   extension: record}
(* Change from record list to array or something*)
and meth = (record list) -> record
let abort _ = exit 0
let int_object i = Empty (Int i)
let string_object s = Empty (String s)
let emptyrecord = Empty EmptyRecord
let assert_fail _ =
  if true then
    failwith \"assertion failed\"
  else emptyrecord
let select field_name record =
  let rec select field_name record =
    match record with
    | Empty _ -> raise Not_found
    | Extension {field_name = field_name'; field_method = field_method;
                 extension = extension} ->
      if field_name = field_name' then
        field_method
      else
        select field_name extension
  in
  select field_name record
(* autogenerated *)
let qdbp_true = (Extension {field_name = \"!\"; field_method = 
  (fun (params: (record list)): record ->
  let var_0_QDBP_VAR = List.hd params in
  let params = List.tl params in
  let var_1_QDBP_VAR = List.hd params in
  let params = List.tl params in
  (
  let var_2_QDBP_VAR = (emptyrecord) in emptyrecord ; 
  ((select (\"#True\") (var_1_QDBP_VAR)) [ (var_2_QDBP_VAR)])
  )); extension = ((emptyrecord))})
(* autogenerated FIXME: Have build system autogen these *)
let qdbp_false = (Extension {field_name = \"!\"; field_method = 
  (fun (params: (record list)): record ->
  let var_0_QDBP_VAR = List.hd params in
  let params = List.tl params in
  let var_1_QDBP_VAR = List.hd params in
  let params = List.tl params in
  (
  let var_2_QDBP_VAR = (emptyrecord) in emptyrecord ; 
  ((select (\"#False\") (var_1_QDBP_VAR)) [ (var_2_QDBP_VAR)])
  )); extension = ((emptyrecord))})
let emit_int_binop op l r =
  match l, r with
  | Empty (Int l), Empty (Int r) ->
    int_object (op l r)
  | _ -> failwith \"expected two ints\"
let emit_string_binop op l r =
  match l, r with
  | Empty (String l), Empty (String r) ->
    string_object (op l r)
  | _ -> failwith \"expected two ints\"
let emit_int_bool_binop op l r =
  match l, r with
  | Empty (Int l), Empty (Int r) ->
    if op l r then qdbp_true else qdbp_false
  | _ -> failwith \"expected two ints\"
let emit_int_unaryop op l =
  match l with
  | Empty (Int l) ->
    int_object (op l)
  | _ -> failwith \"expected an int\"
let emit_string_unaryop op l =
  match l with
  | Empty (String s) ->
    int_object (op s)
  | _ -> failwith \"expected a string\"
let add_int = emit_int_binop (+)
let sub_int = emit_int_binop (-)
let mul_int = emit_int_binop ( * )
let div_int = emit_int_binop (/)
let lt_bool = emit_int_bool_binop (<)
let gt_bool = emit_int_bool_binop (>)
let le_bool = emit_int_bool_binop (<=)
let ge_bool = emit_int_bool_binop (>=)
let eq_bool = emit_int_bool_binop (=)
let ne_bool = emit_int_bool_binop (<>)
let print_int = emit_int_unaryop (fun i -> print_int i; i)
let print_char_int = emit_int_unaryop (fun i -> print_char (char_of_int i); i)
let print_string_int = emit_string_unaryop (fun s -> (print_string s; 0))
let concat_string = emit_string_binop (^)
"
let emptymap = Name_resolver.VarIdMap.empty
let ocaml_of_ast ast =
  let ocaml_code = ocaml_of_ast ast in
  prelude ^ 
  "let result =\n"  ^
  ocaml_code ^ "\n" ^
  (* Make a postlude *)
  "[@@@warning \"+10\"]\n" ^
  "[@@@warning \"+26\"]\n"
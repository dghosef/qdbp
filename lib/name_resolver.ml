module VarIdMap = Map.Make (String)
(* Return a new expression tree with all variables having id nums *)
(* names is a map from name to stack of id numbers *)
(* TODO: Make sure we don't have integer overflow *)
(* FIXME: Do autogenerated random tests *)

(* FIXME: Swap the order of these params *)
(* URGENT: Make sure no duplicate param names *)
let rec name_resolve expr names =
  let add_name name origin name_map =
    VarIdMap.add name origin name_map in
  let resolve_method (meth: Ast.meth) names =
    let add_param names name id =
      add_name name id names
    in
    let names' = List.fold_left2 add_param names meth.args meth.arg_ids in
    let body, _ = name_resolve meth.method_body names' in
    {meth with method_body = body}
  in
  match expr with
  | Ast.RecordExtension r ->
    let f = r.field in 
    let f = {f with field_value = resolve_method f.field_value names} in
    let extension, _ = name_resolve r.extension names in
    Ast.RecordExtension {r with extension = extension; field = f}, names
  | Ast.EmptyRecord -> Ast.EmptyRecord, names
  | Ast.Declaration decl ->
    let rhs, names = name_resolve decl.decl_rhs names in 
    Ast.Declaration {decl with decl_rhs = rhs}, add_name decl.decl_lhs (decl.decl_id) names
  | Ast.Variable variable -> 
    Ast.Variable {variable with origin = VarIdMap.find_opt variable.var_name names},
    names
  | Ast.Record_Message _ -> Ast_utils.ast_local_fold_map name_resolve expr names
  | Ast.Sequence _ -> Ast_utils.ast_local_fold_map name_resolve expr names
  | Ast.OcamlCall _ -> Ast_utils.ast_local_fold_map name_resolve expr names